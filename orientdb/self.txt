1.图的深度遍历
    栈区:每次遍历的顶点都压入栈,在遍历到只有一个出度或者入度的顶点的时候,

    循环开始,找到第一个有效顶点,压入栈,顶点在顶点数组的下标置为--遍历过,
    进入新一轮循环,

    栈区数据类型:顶点下标,顶点已遍历边的下标(避免每次出栈时,从头遍历,对于上百万顶点的图,上百万边的图,
    这时性能的灾难)

    循环终止条件:如过栈的size!=0;一直循环

    初始化条件:将一个顶点的信息入栈

    在什么情况下入栈:
    在什么情况下出栈:如果一个顶点的所有边都遍历完了,可以出栈了
        针对顶点维度进行操作,如果顶点

    0	10	0	0	0	0	0	0	0
    0	0	18	0	0	0	0	0	0
    0	0	0	22	0	0	0	0	0
    0	0	0	0	20	0	0	0	0
    0	0	0	0	0	26	0	0	0
    11	0	0	0	0	0	17	0	0
    0	16	0	24	0	0	0	19	0
    0	0	0	16	7	0	0	0	0
    0	12	8	21	0	0	0	0	0
    上海:1,北京:2,南京:0,天津:3,广州:6,武汉:4,深圳:5,珠海:7,青岛:8,

2.图的广度优先遍历
    根据某个顶点,开始搜索
    队列:将第一个顶点入队,
    循环条件:队列size不为空,出队一个元素,对这个元素进行边遍历,并入队
            判断是否遍历,如果没有,遍历位置为1
3.prim算法
    循环扫描每一个点,如果权值最小,且不存在keyValue中,这条边就加入最小生成树,遍历完所有的节点即可
    输出:最小生成树输出的是边
    要点:最小生成树不是有顶点构成的,而是有边构成的,所以最小生成树的标准就是所有的边
        权值加起来,和最小,因此钥根据边进行去重,已经加入到最小生成树的边就不能再加了
    难点:如何表示边,如何确认边已经成为最小生成树的一部分
    0	10	0	0	0	11	0	0	0
    10	0	18	0	0	0	16	0	12
    0	18	0	22	0	0	0	0	8
    0	0	22	0	20	0	24	16	21
    0	0	0	20	0	26	0	7	0
    11	0	0	0	26	0	17	0	0
    0	16	0	24	0	17	0	19	0
    0	0	0	16	7	0	19	0	0
    0	12	8	21	0	0	0	0	0
    v0:0,v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8


0->1:10
1->0:10
2->8:8
3->7:16
4->3:20
5->6:17
6->5:17
7->4:7
8->2:8
最小生成树的大小:113

4.最短路径（贪心）
    求一个源点到其他所有点的最短路径
